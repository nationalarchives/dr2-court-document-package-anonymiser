var searchIndex = JSON.parse('{\
"anonymiser":{"doc":"Anonymiser script","t":"DLLMMFLLFLLL","n":["Files","borrow","borrow_mut","dir_output","files","files_from_input_arguments","from","into","main","try_from","try_into","type_id"],"q":[[0,"anonymiser"],[12,"anonymiser_lib"],[13,"core::result"],[14,"core::any"]],"d":["The input files and output directory","","","","","Process the input arguments","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","The entrypoint for the anonymiser script","","",""],"i":[0,2,2,2,2,0,2,2,0,2,2,2],"f":[0,[-1,-2,[],[]],[-1,-2,[],[]],0,0,[1,2],[-1,-1,[]],[-1,-2,[],[]],[[],3],[-1,[[4,[-2]]],[],[]],[-1,[[4,[-2]]],[],[]],[-1,5,[]]],"c":[],"p":[[3,"Opt",12],[3,"Files",0],[15,"tuple"],[4,"Result",13],[3,"TypeId",14]]},\
"anonymiser_lib":{"doc":"Court document package anonymiser library","t":"DLLLLLLFFFLLLLFMLFFMFFFLLLLLF","n":["Opt","augment_args","augment_args_for_update","borrow","borrow_mut","command","command_for_update","create_docx_with_checksum","decompress_file","files_in_input_dir","from","from_arg_matches","from_arg_matches_mut","group_id","if_present_delete","input","into","is_file","is_not_hidden","output","parse_metadata_json","process_package","tar_folder","try_from","try_into","type_id","update_from_arg_matches","update_from_arg_matches_mut","update_json_file"],"q":[[0,"anonymiser_lib"],[29,"clap_builder::builder::command"],[30,"std::path"],[31,"serde_json::value"],[32,"alloc::string"],[33,"std::io::error"],[34,"core::result"],[35,"std::path"],[36,"clap_builder::parser::matches::arg_matches"],[37,"clap_builder"],[38,"clap_builder::util::id"],[39,"core::option"],[40,"std::io::error"],[41,"core::any"]],"d":["A struct representing the input arguments","","","","","","","Creates a docx and returns a checksum","Untar and unzip the input tar.gz file","List files in input directory","Returns the argument unchanged.","","","","Helper function to delete a file if present","Input folder","Calls <code>U::from(self)</code>.","Helper function to check if the entry is a file","Helper function to check if a file does not start with <code>.</code>","Output folder","Read the metadata.json file and parse it into a serde <code>Value</code>","Package processor","Tars and Gzips the specified folder","","","","","","Anonymise the contact fields and update the checksum"],"i":[0,11,11,11,11,11,11,0,0,0,11,11,11,11,0,11,11,0,0,11,0,0,0,11,11,11,11,11,0],"f":[0,[1,1],[1,1],[-1,-2,[],[]],[-1,-2,[],[]],[[],1],[[],1],[[2,3],[[6,[4,5]]]],[[7,7],[[6,[8,5]]]],[7,[[6,[[9,[7]],5]]]],[-1,-1,[]],[10,[[6,[11,12]]]],[10,[[6,[11,12]]]],[[],[[14,[13]]]],[7,[[15,[8]]]],0,[-1,-2,[],[]],[16,17],[16,17],0,[7,[[6,[3,5]]]],[[7,7],[[6,[7,5]]]],[[7,7,4],[[6,[8,5]]]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,18,[]],[[11,10],[[6,[8,12]]]],[[11,10],[[6,[8,12]]]],[[7,4,3],[[6,[8,5]]]]],"c":[],"p":[[3,"Command",29],[3,"Path",30],[4,"Value",31],[3,"String",32],[3,"Error",33],[4,"Result",34],[3,"PathBuf",30],[15,"tuple"],[3,"Vec",35],[3,"ArgMatches",36],[3,"Opt",0],[6,"Error",37],[3,"Id",38],[4,"Option",39],[6,"Result",33],[3,"DirEntry",40],[15,"bool"],[3,"TypeId",41]]},\
"lambda":{"doc":"Anonymiser lambda","t":"DDFLLLLFFLLFLLLLLLLLMFMMMLLMLLLLLLF","n":["MessageBody","S3Details","aws_config","borrow","borrow","borrow_mut","borrow_mut","create_s3_client","create_sqs_client","deserialize","deserialize","download","from","from","into","into","into_response","into_response","into_shared","into_shared","parameters","process_record","reference","s3_bucket","s3_key","serialize","serialize","status","try_from","try_from","try_into","try_into","type_id","type_id","upload"],"q":[[0,"lambda"],[35,"core::option"],[36,"aws_types::sdk_config"],[37,"aws_sdk_s3::client"],[38,"aws_sdk_sqs::client"],[39,"core::result"],[40,"serde::de"],[41,"alloc::string"],[42,"std::path"],[43,"std::path"],[44,"hyper::body::body"],[45,"lambda_runtime::types"],[46,"aws_lambda_events::event::sqs"],[47,"serde::ser"],[48,"core::any"]],"d":["The bucket and key for the file we are processing","","Creates an AWS SDK config object","","","","","Creates an S3 client","Creates an SQS client","","","Downloads the specified file","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","Processes the SQS message.","","","","","","","","","","","","","Uploads the specified file"],"i":[0,0,0,6,9,6,9,0,0,6,9,0,6,9,6,9,6,9,6,9,6,0,9,9,9,6,9,9,6,9,6,9,6,9,0],"f":[0,0,[[1,[2,[1]]],3],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[2,[1]]],4],[[[2,[1]]],5],[-1,[[7,[6]]],8],[-1,[[7,[9]]],8],[[4,10,10,11],[[7,[12,13]]]],[-1,-1,[]],[-1,-1,[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[15,[-2,14]]],[],[]],[-1,[[15,[-2,14]]],[],[]],[-1,-2,[],[]],[-1,-2,[],[]],0,[[16,12,[2,[1]],[2,[1]]],[[7,[12,13]]]],0,0,0,[[6,-1],7,17],[[9,-1],7,17],0,[-1,[[7,[-2]]],[],[]],[-1,[[7,[-2]]],[],[]],[-1,[[7,[-2]]],[],[]],[-1,[[7,[-2]]],[],[]],[-1,18,[]],[-1,18,[]],[[4,12,1,1],[[7,[19,13]]]]],"c":[],"p":[[15,"str"],[4,"Option",35],[3,"SdkConfig",36],[3,"Client",37],[3,"Client",38],[3,"MessageBody",0],[4,"Result",39],[8,"Deserializer",40],[3,"S3Details",0],[3,"String",41],[3,"Path",42],[3,"PathBuf",42],[6,"Error",43],[3,"Body",44],[4,"FunctionResponse",45],[3,"SqsMessage",46],[8,"Serializer",47],[3,"TypeId",48],[15,"tuple"]]},\
"testlib":{"doc":"Test library functions","t":"DLLMMMFFLFLFFLLLF","n":["MetadataJson","borrow","borrow_mut","checksum","contact_email","contact_name","create_package","decompress_test_file","from","get_metadata_json_fields","into","json_missing_filename","metadata_from_json_value","try_from","try_into","type_id","valid_json"],"q":[[0,"testlib"],[17,"assert_fs::fixture::dir"],[18,"alloc::string"],[19,"core::option"],[20,"std::path"],[21,"std::path"],[22,"core::result"],[23,"core::any"]],"d":["Represents the fields to be anonymised","","","","","","Creates a test tar.gz file","Decompresses the test tar.gz file","Returns the argument unchanged.","Read the metadata.json file and parse the fields to be â€¦","Calls <code>U::from(self)</code>.","An input string with the filename missing","Parse the fields from the json value","","","","An valid input string"],"i":[0,8,8,8,8,8,0,0,8,0,8,0,0,8,8,8,0],"f":[0,[-1,-2,[],[]],[-1,-2,[],[]],0,0,0,[[1,2,[4,[3]]],5],[[5,1],6],[-1,-1,[]],[7,8],[-1,-2,[],[]],[[],2],[9,8],[-1,[[10,[-2]]],[],[]],[-1,[[10,[-2]]],[],[]],[-1,11,[]],[[],2]],"c":[],"p":[[3,"TempDir",17],[15,"str"],[3,"String",18],[4,"Option",19],[3,"PathBuf",20],[15,"tuple"],[3,"Path",20],[3,"MetadataJson",0],[4,"Value",21],[4,"Result",22],[3,"TypeId",23]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
