var searchIndex = JSON.parse('{\
"anonymise":{"doc":"Court document package anonymiser library","t":"DLLLLLLFFFLLLLFMLFFMFFFLLLLLF","n":["Opt","augment_args","augment_args_for_update","borrow","borrow_mut","command","command_for_update","create_docx_with_checksum","decompress_file","files_in_input_dir","from","from_arg_matches","from_arg_matches_mut","group_id","if_present_delete","input","into","is_file","is_not_hidden","output","parse_metadata_json","process_package","tar_folder","try_from","try_into","type_id","update_from_arg_matches","update_from_arg_matches_mut","update_json_file"],"q":[[0,"anonymise"],[29,"clap_builder::builder::command"],[30,"std::path"],[31,"serde_json::value"],[32,"alloc::string"],[33,"std::io::error"],[34,"core::result"],[35,"std::path"],[36,"clap_builder::parser::matches::arg_matches"],[37,"clap_builder"],[38,"clap_builder::util::id"],[39,"core::option"],[40,"std::io::error"],[41,"core::any"]],"d":["A struct representing the input arguments","","","","","","","Creates a docx and returns a checksum","Untar and unzip the input tar.gz file","List files in input directory","Returns the argument unchanged.","","","","Helper function to delete a file if present","Input folder","Calls <code>U::from(self)</code>.","Helper function to check if the entry is a file","Helper function to check if a file does not start with <code>.</code>","Output folder","Read the metadata.json file and parse it into a serde <code>Value</code>","Package processor","Tars and Gzips the specified folder","","","","","","Anonymise the contact fields and update the checksum"],"i":[0,11,11,11,11,11,11,0,0,0,11,11,11,11,0,11,11,0,0,11,0,0,0,11,11,11,11,11,0],"f":[0,[1,1],[1,1],[-1,-2,[],[]],[-1,-2,[],[]],[[],1],[[],1],[[2,3],[[6,[4,5]]]],[[7,7],[[6,[8,5]]]],[7,[[6,[[9,[7]],5]]]],[-1,-1,[]],[10,[[6,[11,12]]]],[10,[[6,[11,12]]]],[[],[[14,[13]]]],[7,[[15,[8]]]],0,[-1,-2,[],[]],[16,17],[16,17],0,[7,[[6,[3,5]]]],[[7,7],[[6,[7,5]]]],[[7,7,4],[[6,[8,5]]]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,18,[]],[[11,10],[[6,[8,12]]]],[[11,10],[[6,[8,12]]]],[[7,4,3],[[6,[8,5]]]]],"c":[],"p":[[3,"Command",29],[3,"Path",30],[4,"Value",31],[3,"String",32],[3,"Error",33],[4,"Result",34],[3,"PathBuf",30],[15,"tuple"],[3,"Vec",35],[3,"ArgMatches",36],[3,"Opt",0],[6,"Error",37],[3,"Id",38],[4,"Option",39],[6,"Result",33],[3,"DirEntry",40],[15,"bool"],[3,"TypeId",41]]},\
"anonymiser":{"doc":"Anonymiser script","t":"DLLMMFLLFLLL","n":["Files","borrow","borrow_mut","dir_output","files","files_from_input_arguments","from","into","main","try_from","try_into","type_id"],"q":[[0,"anonymiser"],[12,"anonymise"],[13,"core::result"],[14,"core::any"]],"d":["The input files and output directory","","","","","Process the input arguments","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","The entrypoint for the anonymiser script","","",""],"i":[0,2,2,2,2,0,2,2,0,2,2,2],"f":[0,[-1,-2,[],[]],[-1,-2,[],[]],0,0,[1,2],[-1,-1,[]],[-1,-2,[],[]],[[],3],[-1,[[4,[-2]]],[],[]],[-1,[[4,[-2]]],[],[]],[-1,5,[]]],"c":[],"p":[[3,"Opt",12],[3,"Files",0],[15,"tuple"],[4,"Result",13],[3,"TypeId",14]]},\
"lambda":{"doc":"Anonymiser lambda","t":"DLLMFFLFLLMFLLLF","n":["S3Details","borrow","borrow_mut","bucket","create_s3_client","download","from","get_s3_details","into","into_shared","key","process_record","try_from","try_into","type_id","upload"],"q":[[0,"lambda"],[16,"core::option"],[17,"aws_sdk_s3::client"],[18,"alloc::string"],[19,"std::path"],[20,"lambda_runtime"],[21,"core::result"],[22,"aws_lambda_events::event::sqs"],[23,"core::any"]],"d":["The bucket and key for the file we are processing","","","","Creates an S3 client","Downloads the specified file","Returns the argument unchanged.","Parses the s3 input details","Calls <code>U::from(self)</code>.","","","Processes the SQS message.","","","","Uploads the specified file"],"i":[0,9,9,9,0,0,9,0,9,9,9,0,9,9,9,0],"f":[0,[-1,-2,[],[]],[-1,-2,[],[]],0,[[[2,[1]]],3],[[3,4,4,5],[[7,[5,6]]]],[-1,-1,[]],[8,[[7,[9,6]]]],[-1,-2,[],[]],[-1,-2,[],[]],0,[[8,5,[2,[1]]],[[7,[5,6]]]],[-1,[[7,[-2]]],[],[]],[-1,[[7,[-2]]],[],[]],[-1,10,[]],[[3,5,1,1],[[7,[11,6]]]]],"c":[],"p":[[15,"str"],[4,"Option",16],[3,"Client",17],[3,"String",18],[3,"PathBuf",19],[6,"Error",20],[4,"Result",21],[3,"SqsMessage",22],[3,"S3Details",0],[3,"TypeId",23],[15,"tuple"]]},\
"testlib":{"doc":"Test library functions","t":"DLLMMMFFLFLFFLLLF","n":["MetadataJson","borrow","borrow_mut","checksum","contact_email","contact_name","create_package","decompress_test_file","from","get_metadata_json_fields","into","json_missing_filename","metadata_from_json_value","try_from","try_into","type_id","valid_json"],"q":[[0,"testlib"],[17,"assert_fs::fixture::dir"],[18,"alloc::string"],[19,"core::option"],[20,"std::path"],[21,"std::path"],[22,"core::result"],[23,"core::any"]],"d":["Represents the fields to be anonymised","","","","","","Creates a test tar.gz file","Decompresses the test tar.gz file","Returns the argument unchanged.","Read the metadata.json file and parse the fields to be â€¦","Calls <code>U::from(self)</code>.","An input string with the filename missing","Parse the fields from the json value","","","","An valid input string"],"i":[0,8,8,8,8,8,0,0,8,0,8,0,0,8,8,8,0],"f":[0,[-1,-2,[],[]],[-1,-2,[],[]],0,0,0,[[1,2,[4,[3]]],5],[[5,1],6],[-1,-1,[]],[7,8],[-1,-2,[],[]],[[],2],[9,8],[-1,[[10,[-2]]],[],[]],[-1,[[10,[-2]]],[],[]],[-1,11,[]],[[],2]],"c":[],"p":[[3,"TempDir",17],[15,"str"],[3,"String",18],[4,"Option",19],[3,"PathBuf",20],[15,"tuple"],[3,"Path",20],[3,"MetadataJson",0],[4,"Value",21],[4,"Result",22],[3,"TypeId",23]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
